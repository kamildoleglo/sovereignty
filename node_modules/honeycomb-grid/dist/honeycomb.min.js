!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(t.Honeycomb={})}(this,function(t){"use strict";"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var n,e=(function(t,n){t.exports=function(){var t={},n="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function e(){return Object.prototype.toString.call(this).slice(8,-1)}for(var r=n.length;r--;)t["is"+n[r]]=function(t){return function(n){return e.call(n)===t}}(n[r]);return t}()}(n={exports:{}},n.exports),n.exports),r=e.isObject,i=e.isNumber,o=e.isArray,s=e.isString;function u(t,n){return n+t*(1&n)>>1}function c(t,n){return(t%n+n)%n}function a(t,n){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);if(n=n.toLowerCase(),t=t.toUpperCase(),"pointy"===n&&["N","S"].includes(t))throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);if("flat"===n&&["E","W"].includes(t))throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[n][t]}function f(t,n){return i(t)||i(n)?i(t)?i(n)||(n=t):t=n:t=n=0,{x:t,y:n}}function h(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function l(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{},r=Object.keys(e);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(e).filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.forEach(function(n){h(t,n,e[n])})}return t}function d(t,n){if(null==t)return{};var e,r,i=function(t,n){if(null==t)return{};var e,r,i={},o=Object.keys(t);for(r=0;r<o.length;r++)e=o[r],n.indexOf(e)>=0||(i[e]=t[e]);return i}(t,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)e=o[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(i[e]=t[e])}return i}function x(t,n){return function(t){if(Array.isArray(t))return t}(t)||function(t,n){var e=[],r=!0,i=!1,o=void 0;try{for(var s,u=t[Symbol.iterator]();!(r=(s=u.next()).done)&&(e.push(s.value),!n||e.length!==n);r=!0);}catch(t){i=!0,o=t}finally{try{r||null==u.return||u.return()}finally{if(i)throw o}}return e}(t,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}const p=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}],y=[{q:2,r:-1},{q:1,r:1},{q:-1,r:2},{q:-2,r:1},{q:-1,r:-1},{q:1,r:-2}],b={x:1e-6,y:1e-6},g=Math.sqrt(3);function q(){return{x:this.x,y:this.y}}function m(){return{q:this.q,r:this.r,s:this.s}}function P({q:t,r:n}){let e,r;return this.isPointy()?(e=t+u(this.offset,n),r=n):(e=t,r=n+u(this.offset,t)),{x:e,y:r}}function w(){return"pointy"===this.orientation.toLowerCase()}function H(){return"flat"===this.orientation.toLowerCase()}function O(){return 2*this.size}function C(){return g/2*this.oppositeCornerDistance()}function v(){return this.isPointy()?this.oppositeSideDistance():this.oppositeCornerDistance()}function E(){return this.isPointy()?this.oppositeCornerDistance():this.oppositeSideDistance()}function S(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function j(){return this.add(b)}function M(){return`${this.x},${this.y}`}const N={thirdCoordinate:function(t,n){return-t-n}};function T(t){return i(t)?this[t]:this[this.indexOf(t)]}function D(t,n){const e=t.distance(n),r=1/Math.max(e,1);let i=[];for(let o=0;o<=e;o++){const e=t.nudge().lerp(n.nudge(),r*o).round();i.push(this.get(e))}return i}function $({ensureXY:t}){const n={add:function({Point:t}){return function(n,e){let r;var i=t(n,e);return r=i.x,e=i.y,t(this.x+r,this.y+e)}}({Point:e}),subtract:function({Point:t}){return function(n,e){let r;var i=t(n,e);return r=i.x,e=i.y,t(this.x-r,this.y-e)}}({Point:e}),multiply:function({Point:t}){return function(n,e){let r;var i=t(n,e);return r=i.x,e=i.y,t(this.x*r,this.y*e)}}({Point:e}),divide:function({Point:t}){return function(n,e){let r;var i=t(n,e);return r=i.x,e=i.y,t(this.x/r,this.y/e)}}({Point:e})};function e(e,s){let u;return u=i(e)?t(e,s):o(e)?t(...e):r(e)?t(e.x,e.y):t(0),Object.assign(Object.create(n),u)}return e}const G=$({ensureXY:f});class V extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t,n=0){return!!(this.indexOf(t,n)+1)}indexOf(t,n=0){const e=this.length;let r=Number(n);for(t=G(t),r=Math.max(r>=0?r:e+r,0);r<e;r++)if(this[r].equals(t))return r;return-1}lastIndexOf(t,n=this.length-1){const e=this.length;let r=Number(n);for(t=G(t),r=r>=0?Math.min(r,e-1):e+r;r>=0;r--)if(this[r].equals(t))return r;return-1}push(...t){return super.push(...t.filter(V.isValidHex))}splice(t,n,...e){return null==n?super.splice(t):super.splice(t,n,...e.filter(V.isValidHex))}unshift(...t){return super.unshift(...t.filter(V.isValidHex))}}const W=$({ensureXY:f}),I=function({ensureXY:t,Point:n}){return function(e={}){const s=function({Point:t}){return function(n,e){let r,i,o;var s=t(n,e);return r=s.x,e=s.y,this.isPointy()?(i=r-u(this.offset,e),o=e):(i=r,o=e-u(this.offset,r)),{q:i,r:o,s:-i-o}}}({Point:n}),c={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:1,offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:function({Hex:t,Point:n}){return function(e){const r=n(e),i=r.x,o=r.y;return t(this.x+i,this.y+o,l({},this))}}({Hex:f,Point:n}),cartesian:q,cartesianToCube:s,center:function({Point:t}){return function(){const n=this.origin,e=n.x,r=n.y;return t(this.width()/2-e,this.height()/2-r)}}({Point:n}),coordinates:q,corners:function({Point:t}){return function(){const n=this.width(),e=this.height(),r=this.origin,i=r.x,o=r.y;return this.isPointy()?[t(n-i,.25*e-o),t(n-i,.75*e-o),t(.5*n-i,e-o),t(0-i,.75*e-o),t(0-i,.25*e-o),t(.5*n-i,0-o)]:[t(n-i,.5*e-o),t(.75*n-i,e-o),t(.25*n-i,e-o),t(0-i,.5*e-o),t(.25*n-i,0-o),t(.75*n-i,0-o)]}}({Point:n}),cube:m,cubeToCartesian:P,distance:S,equals:function({Point:t}){return function(n){const e=t(n),r=e.x,i=e.y;return this.x===r&&this.y===i}}({Point:n}),fromPoint:function({Point:t,Hex:n}){return function(e,r){const i=this.size;let o,s,u;var c=t(e,r).subtract(this.center());return o=c.x,r=c.y,this.isPointy()?(s=(o*g/3-r/3)/i,u=2*r/3/i):(s=2*o/3/i,u=(-o/3+g/3*r)/i),n({q:s,r:u,s:-s-u}).round()}}({Point:n,Hex:f}),height:E,isFlat:H,isPointy:w,lerp:function({Hex:t}){return function(n,e){const r=this.q*(1-e)+n.q*e,i=this.r*(1-e)+n.r*e;return t(l({},this,{q:r,r:i,s:-r-i}))}}({Hex:f}),nudge:j,oppositeCornerDistance:O,oppositeSideDistance:C,round:function({Hex:t}){return function(){let n=this.q,e=this.r,r=this.s,i=Math.round(n),o=Math.round(e),s=Math.round(r);const u=Math.abs(n-i),c=Math.abs(e-o),a=Math.abs(r-s);return u>c&&u>a?i=-o-s:c>a?o=-i-s:s=-i-o,t(l({},this,{q:i,r:o,s:s}))}}({Hex:f}),set:function({Hex:t}){return function(...n){return Object.assign(this,t(...n))}}({Hex:f}),subtract:function({Hex:t,Point:n}){return function(e){const r=n(e),i=r.x,o=r.y;return t(this.x-i,this.y-o,l({},this))}}({Hex:f,Point:n}),toCartesian:P,toCube:s,toPoint:function({Point:t}){return function(){const n=this.q,e=this.r,r=this.size;let i,o;return this.isPointy()?(i=r*g*(n+e/2),o=3*r/2*e):(i=3*r/2*n,o=r*g*(e+n/2)),t(i,o)}}({Point:n}),toString:M,width:v},a=Object.assign(c,e);function f(n,e,s={}){let u;if(r(n)){let t=n.q,r=n.r,o=n.s,f=d(n,["q","r","s"]);if(i(t)||i(r)||i(o)){if(t+r+o!==0)throw new Error(`Cube coordinates must have a sum of 0. q: ${t}, r: ${r}, s: ${o}, sum: ${t+r+o}.`);var c=a.cubeToCartesian({q:t,r:r,s:o});u=c.x,e=c.y}else u=n.x,e=n.y;s=f}else if(o(n)){var f=x(n,2);u=f[0],e=f[1],s={}}else u=n;return Object.assign(Object.create(a),Object.assign(s,t(u,e)))}return a.origin=n(a.origin),Object.assign(f,N),f}}({ensureXY:f,Point:W}),_=function({extendHex:t,Grid:n,Point:e}){const r=n.isValidHex;return function(f=t()){function h(t,...e){return o(t)?e=t:e.unshift(t),new n(...e.filter(r))}return Object.assign(h,{Hex:f,isValidHex:r,pointToHex:function({Hex:t}){return function(n,e){return t().fromPoint(n,e)}}({Point:e,Hex:f}),parallelogram:function({Grid:t,Hex:n}){return function({width:e,height:r,start:i,direction:o=1,onCreate:s=(()=>{})}){i=n(i);const u=x({1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[o],3),c=u[0],a=u[1],f=u[2],h=new t;for(let t=0;t<e;t++)for(let e=0;e<r;e++){const r=n(i.cubeToCartesian({[c]:t+i[c],[a]:e+i[a],[f]:-t-e+i[f]}));s(r,h),h.push(r)}return h}}({Grid:n,Hex:f}),triangle:function({Grid:t,Hex:n}){return function({size:e,start:r,direction:i=1,onCreate:o=(()=>{})}){r=n(r);const s={1:{rStart:()=>0,rEnd:t=>e-t},5:{rStart:t=>e-t,rEnd:()=>e+1}}[i],u=s.rStart,c=s.rEnd,a=new t;for(let t=0;t<e;t++)for(let e=u(t);e<c(t);e++){const i=n(r.cubeToCartesian({q:t+r.q,r:e+r.r,s:-t-e+r.s}));o(i,a),a.push(i)}return a}}({Grid:n,Hex:f}),hexagon:function({Grid:t,Hex:n}){return function({radius:e,center:r,onCreate:i=(()=>{})}){r=n(r);const o=new t;for(let t=-e;t<=e;t++){const s=Math.max(-e,-t-e),u=Math.min(e,-t+e);for(let e=s;e<=u;e++){const s=n(r.cubeToCartesian({q:t+r.q,r:e+r.r,s:-t-e+r.s}));i(s,o),o.push(s)}}return o}}({Grid:n,Hex:f}),rectangle:function({Grid:t,Hex:n,compassToNumberDirection:e,signedModulo:r}){return function({width:i,height:o,start:c,direction:a=(n().isPointy()?0:1),onCreate:f=(()=>{})}){c=n(c),s(a)&&(a=e(a,c.orientation)),(a<0||a>5)&&(a=r(a,6));const h=x([["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][a],3),l=h[0],d=h[1],p=h[2],y=x(c.isPointy()?[i,o]:[o,i],2),b=y[0],g=y[1],q=new t;for(let t=0;t<g;t++){const e=u(c.offset,t);for(let r=-e;r<b-e;r++){const e=n(c.cubeToCartesian({[l]:r+c[l],[d]:t+c[d],[p]:-r-t+c[p]}));f(e,q),q.push(e)}}return q}}({Grid:n,Hex:f,compassToNumberDirection:a,signedModulo:c})}),Object.assign(n.prototype,{get:T,hexesBetween:D,hexesInRange:function({isValidHex:t}){return function(n,e=0,r=!0){if(!t(n))throw new Error(`Invalid center hex: ${n}.`);if(!this.get(n))throw new Error(`Center hex with coordinates ${n} not present in grid.`);let i=[];for(let t=-e;t<=e;t++)for(let o=Math.max(-e,-t-e);o<=Math.min(e,-t+e);o++){const e=this.get(n.cubeToCartesian({q:n.q+t,r:n.r+o}));n.equals(e)&&!r||i.push(e)}return i.filter(Boolean)}}({isValidHex:r}),neighborsOf:function({isValidHex:t,signedModulo:n,compassToNumberDirection:e}){return function(r,i="all",o=!1){if(!t(r))throw new Error(`Invalid hex: ${r}.`);const u=o?y:p;return"all"===i&&(i=[0,1,2,3,4,5]),[].concat(i).map(t=>{s(t)&&(t=e(t,r.orientation)),(t<0||t>5)&&(t=n(t,6));const i=u[t],o=i.q,c=i.r;return this.get(r.cubeToCartesian({q:r.q+o,r:r.r+c}))}).filter(Boolean)}}({isValidHex:r,signedModulo:c,compassToNumberDirection:a}),set:function({isValidHex:t}){return function(n,e){if(!t(e))return this;const r=i(n)?n:this.indexOf(n);return r<0?this.push(e):this[r]=e,this}}({isValidHex:r})}),h}}({extendHex:I,Grid:V,Point:W});t.extendHex=I,t.defineGrid=_,t.Point=W,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=honeycomb.min.js.map
