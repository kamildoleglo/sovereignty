var commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(t,e){return t(e={exports:{}},e.exports),e.exports}var axis=createCommonjsModule(function(t,e){t.exports=function(){var t={},e="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function r(){return Object.prototype.toString.call(this).slice(8,-1)}for(var n=e.length;n--;)t["is"+e[n]]=function(t){return function(e){return r.call(e)===t}}(e[n]);return t}()}),axis_1=axis.isObject,axis_2=axis.isNumber,axis_3=axis.isArray,axis_4=axis.isString;function offsetFromZero(t,e){return e+t*(1&e)>>1}function signedModulo(t,e){return(t%e+e)%e}function compassToNumberDirection(t,e){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);if(e=e.toLowerCase(),t=t.toUpperCase(),"pointy"===e&&["N","S"].includes(t))throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);if("flat"===e&&["E","W"].includes(t))throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[e][t]}function ensureXY(t,e){return axis_2(t)||axis_2(e)?axis_2(t)?axis_2(e)||(e=t):t=e:t=e=0,{x:t,y:e}}function _defineProperty(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function _objectSpread(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{},n=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter(function(t){return Object.getOwnPropertyDescriptor(r,t).enumerable}))),n.forEach(function(e){_defineProperty(t,e,r[e])})}return t}function _objectWithoutPropertiesLoose(t,e){if(null==t)return{};var r,n,i={},o=Object.keys(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||(i[r]=t[r]);return i}function _objectWithoutProperties(t,e){if(null==t)return{};var r,n,i=_objectWithoutPropertiesLoose(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(i[r]=t[r])}return i}function _slicedToArray(t,e){return _arrayWithHoles(t)||_iterableToArrayLimit(t,e)||_nonIterableRest()}function _arrayWithHoles(t){if(Array.isArray(t))return t}function _iterableToArrayLimit(t,e){var r=[],n=!0,i=!1,o=void 0;try{for(var s,a=t[Symbol.iterator]();!(n=(s=a.next()).done)&&(r.push(s.value),!e||r.length!==e);n=!0);}catch(t){i=!0,o=t}finally{try{n||null==a.return||a.return()}finally{if(i)throw o}}return r}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function thirdCoordinate(t,e){return-t-e}const DIRECTION_COORDINATES=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}],DIAGONAL_DIRECTION_COORDINATES=[{q:2,r:-1},{q:1,r:1},{q:-1,r:2},{q:-2,r:1},{q:-1,r:-1},{q:1,r:-2}],EPSILON={x:1e-6,y:1e-6},sqrt3=Math.sqrt(3);function setFactory({Hex:t}){return function(...e){return Object.assign(this,t(...e))}}function coordinates(){return{x:this.x,y:this.y}}function cube(){return{q:this.q,r:this.r,s:this.s}}function cubeToCartesian({q:t,r:e}){let r,n;return this.isPointy()?(r=t+offsetFromZero(this.offset,e),n=e):(r=t,n=e+offsetFromZero(this.offset,t)),{x:r,y:n}}function cartesianToCubeFactory({Point:t}){return function(e,r){let n,i,o;var s=t(e,r);return n=s.x,r=s.y,this.isPointy()?(i=n-offsetFromZero(this.offset,r),o=r):(i=n,o=r-offsetFromZero(this.offset,n)),{q:i,r:o,s:-i-o}}}function isPointy(){return"pointy"===this.orientation.toLowerCase()}function isFlat(){return"flat"===this.orientation.toLowerCase()}function oppositeCornerDistance(){return 2*this.size}function oppositeSideDistance(){return sqrt3/2*this.oppositeCornerDistance()}function width(){return this.isPointy()?this.oppositeSideDistance():this.oppositeCornerDistance()}function height(){return this.isPointy()?this.oppositeCornerDistance():this.oppositeSideDistance()}function cornersFactory({Point:t}){return function(){const e=this.width(),r=this.height(),n=this.origin,i=n.x,o=n.y;return this.isPointy()?[t(e-i,.25*r-o),t(e-i,.75*r-o),t(.5*e-i,r-o),t(0-i,.75*r-o),t(0-i,.25*r-o),t(.5*e-i,0-o)]:[t(e-i,.5*r-o),t(.75*e-i,r-o),t(.25*e-i,r-o),t(0-i,.5*r-o),t(.25*e-i,0-o),t(.75*e-i,0-o)]}}function centerFactory({Point:t}){return function(){const e=this.origin,r=e.x,n=e.y;return t(this.width()/2-r,this.height()/2-n)}}function toPointFactory({Point:t}){return function(){const e=this.q,r=this.r,n=this.size;let i,o;return this.isPointy()?(i=n*sqrt3*(e+r/2),o=3*n/2*r):(i=3*n/2*e,o=n*sqrt3*(r+e/2)),t(i,o)}}function fromPointFactory({Point:t,Hex:e}){return function(r,n){const i=this.size;let o,s,a;var c=t(r,n).subtract(this.center());return o=c.x,n=c.y,this.isPointy()?(s=(o*sqrt3/3-n/3)/i,a=2*n/3/i):(s=2*o/3/i,a=(-o/3+sqrt3/3*n)/i),e({q:s,r:a,s:-s-a}).round()}}function addFactory({Hex:t,Point:e}){return function(r){const n=e(r),i=n.x,o=n.y;return t(this.x+i,this.y+o,_objectSpread({},this))}}function subtractFactory({Hex:t,Point:e}){return function(r){const n=e(r),i=n.x,o=n.y;return t(this.x-i,this.y-o,_objectSpread({},this))}}function equalsFactory({Point:t}){return function(e){const r=t(e),n=r.x,i=r.y;return this.x===n&&this.y===i}}function distance(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function roundFactory({Hex:t}){return function(){let e=this.q,r=this.r,n=this.s,i=Math.round(e),o=Math.round(r),s=Math.round(n);const a=Math.abs(e-i),c=Math.abs(r-o),u=Math.abs(n-s);return a>c&&a>u?i=-o-s:c>u?o=-i-s:s=-i-o,t(_objectSpread({},this,{q:i,r:o,s:s}))}}function lerpFactory({Hex:t}){return function(e,r){const n=this.q*(1-r)+e.q*r,i=this.r*(1-r)+e.r*r;return t(_objectSpread({},this,{q:n,r:i,s:-n-i}))}}function nudge(){return this.add(EPSILON)}function toString(){return`${this.x},${this.y}`}const staticMethods={thirdCoordinate:thirdCoordinate};function extendHexFactory({ensureXY:t,Point:e}){return function(r={}){const n=cartesianToCubeFactory({Point:e}),i={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:1,offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:addFactory({Hex:s,Point:e}),cartesian:coordinates,cartesianToCube:n,center:centerFactory({Point:e}),coordinates:coordinates,corners:cornersFactory({Point:e}),cube:cube,cubeToCartesian:cubeToCartesian,distance:distance,equals:equalsFactory({Point:e}),fromPoint:fromPointFactory({Point:e,Hex:s}),height:height,isFlat:isFlat,isPointy:isPointy,lerp:lerpFactory({Hex:s}),nudge:nudge,oppositeCornerDistance:oppositeCornerDistance,oppositeSideDistance:oppositeSideDistance,round:roundFactory({Hex:s}),set:setFactory({Hex:s}),subtract:subtractFactory({Hex:s,Point:e}),toCartesian:cubeToCartesian,toCube:n,toPoint:toPointFactory({Point:e}),toString:toString,width:width},o=Object.assign(i,r);function s(e,r,n={}){let i;if(axis_1(e)){let t=e.q,a=e.r,c=e.s,u=_objectWithoutProperties(e,["q","r","s"]);if(axis_2(t)||axis_2(a)||axis_2(c)){if(t+a+c!==0)throw new Error(`Cube coordinates must have a sum of 0. q: ${t}, r: ${a}, s: ${c}, sum: ${t+a+c}.`);var s=o.cubeToCartesian({q:t,r:a,s:c});i=s.x,r=s.y}else i=e.x,r=e.y;n=u}else if(axis_3(e)){var a=_slicedToArray(e,2);i=a[0],r=a[1],n={}}else i=e;return Object.assign(Object.create(o),Object.assign(n,t(i,r)))}return o.origin=e(o.origin),Object.assign(s,staticMethods),s}}function pointToHexFactory({Hex:t}){return function(e,r){return t().fromPoint(e,r)}}function parallelogramFactory({Grid:t,Hex:e}){return function({width:r,height:n,start:i,direction:o=1,onCreate:s=(()=>{})}){i=e(i);const a=_slicedToArray({1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[o],3),c=a[0],u=a[1],f=a[2],h=new t;for(let t=0;t<r;t++)for(let r=0;r<n;r++){const n=e(i.cubeToCartesian({[c]:t+i[c],[u]:r+i[u],[f]:-t-r+i[f]}));s(n,h),h.push(n)}return h}}function triangleFactory({Grid:t,Hex:e}){return function({size:r,start:n,direction:i=1,onCreate:o=(()=>{})}){n=e(n);const s={1:{rStart:()=>0,rEnd:t=>r-t},5:{rStart:t=>r-t,rEnd:()=>r+1}}[i],a=s.rStart,c=s.rEnd,u=new t;for(let t=0;t<r;t++)for(let r=a(t);r<c(t);r++){const i=e(n.cubeToCartesian({q:t+n.q,r:r+n.r,s:-t-r+n.s}));o(i,u),u.push(i)}return u}}function hexagonFactory({Grid:t,Hex:e}){return function({radius:r,center:n,onCreate:i=(()=>{})}){n=e(n);const o=new t;for(let t=-r;t<=r;t++){const s=Math.max(-r,-t-r),a=Math.min(r,-t+r);for(let r=s;r<=a;r++){const s=e(n.cubeToCartesian({q:t+n.q,r:r+n.r,s:-t-r+n.s}));i(s,o),o.push(s)}}return o}}function rectangleFactory({Grid:t,Hex:e,compassToNumberDirection:r,signedModulo:n}){return function({width:i,height:o,start:s,direction:a=(e().isPointy()?0:1),onCreate:c=(()=>{})}){s=e(s),axis_4(a)&&(a=r(a,s.orientation)),(a<0||a>5)&&(a=n(a,6));const u=_slicedToArray([["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][a],3),f=u[0],h=u[1],l=u[2],d=_slicedToArray(s.isPointy()?[i,o]:[o,i],2),y=d[0],x=d[1],p=new t;for(let t=0;t<x;t++){const r=offsetFromZero(s.offset,t);for(let n=-r;n<y-r;n++){const r=e(s.cubeToCartesian({[f]:n+s[f],[h]:t+s[h],[l]:-n-t+s[l]}));c(r,p),p.push(r)}}return p}}function get(t){return axis_2(t)?this[t]:this[this.indexOf(t)]}function setFactory$1({isValidHex:t}){return function(e,r){if(!t(r))return this;const n=axis_2(e)?e:this.indexOf(e);return n<0?this.push(r):this[n]=r,this}}function hexesBetween(t,e){const r=t.distance(e),n=1/Math.max(r,1);let i=[];for(let o=0;o<=r;o++){const r=t.nudge().lerp(e.nudge(),n*o).round();i.push(this.get(r))}return i}function hexesInRangeFactory({isValidHex:t}){return function(e,r=0,n=!0){if(!t(e))throw new Error(`Invalid center hex: ${e}.`);if(!this.get(e))throw new Error(`Center hex with coordinates ${e} not present in grid.`);let i=[];for(let t=-r;t<=r;t++)for(let o=Math.max(-r,-t-r);o<=Math.min(r,-t+r);o++){const r=this.get(e.cubeToCartesian({q:e.q+t,r:e.r+o}));e.equals(r)&&!n||i.push(r)}return i.filter(Boolean)}}function neighborsOfFactory({isValidHex:t,signedModulo:e,compassToNumberDirection:r}){return function(n,i="all",o=!1){if(!t(n))throw new Error(`Invalid hex: ${n}.`);const s=o?DIAGONAL_DIRECTION_COORDINATES:DIRECTION_COORDINATES;return"all"===i&&(i=[0,1,2,3,4,5]),[].concat(i).map(t=>{axis_4(t)&&(t=r(t,n.orientation)),(t<0||t>5)&&(t=e(t,6));const i=s[t],o=i.q,a=i.r;return this.get(n.cubeToCartesian({q:n.q+o,r:n.r+a}))}).filter(Boolean)}}function defineGridFactory({extendHex:t,Grid:e,Point:r}){const n=e.isValidHex;return function(i=t()){function o(t,...r){return axis_3(t)?r=t:r.unshift(t),new e(...r.filter(n))}return Object.assign(o,{Hex:i,isValidHex:n,pointToHex:pointToHexFactory({Point:r,Hex:i}),parallelogram:parallelogramFactory({Grid:e,Hex:i}),triangle:triangleFactory({Grid:e,Hex:i}),hexagon:hexagonFactory({Grid:e,Hex:i}),rectangle:rectangleFactory({Grid:e,Hex:i,compassToNumberDirection:compassToNumberDirection,signedModulo:signedModulo})}),Object.assign(e.prototype,{get:get,hexesBetween:hexesBetween,hexesInRange:hexesInRangeFactory({isValidHex:n}),neighborsOf:neighborsOfFactory({isValidHex:n,signedModulo:signedModulo,compassToNumberDirection:compassToNumberDirection}),set:setFactory$1({isValidHex:n})}),o}}function addFactory$1({Point:t}){return function(e,r){let n;var i=t(e,r);return n=i.x,r=i.y,t(this.x+n,this.y+r)}}function subtractFactory$1({Point:t}){return function(e,r){let n;var i=t(e,r);return n=i.x,r=i.y,t(this.x-n,this.y-r)}}function multiplyFactory({Point:t}){return function(e,r){let n;var i=t(e,r);return n=i.x,r=i.y,t(this.x*n,this.y*r)}}function divideFactory({Point:t}){return function(e,r){let n;var i=t(e,r);return n=i.x,r=i.y,t(this.x/n,this.y/r)}}function PointFactory({ensureXY:t}){const e={add:addFactory$1({Point:r}),subtract:subtractFactory$1({Point:r}),multiply:multiplyFactory({Point:r}),divide:divideFactory({Point:r})};function r(r,n){let i;return i=axis_2(r)?t(r,n):axis_3(r)?t(...r):axis_1(r)?t(r.x,r.y):t(0),Object.assign(Object.create(e),i)}return r}const Point=PointFactory({ensureXY:ensureXY});class Grid extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t,e=0){return!!(this.indexOf(t,e)+1)}indexOf(t,e=0){const r=this.length;let n=Number(e);for(t=Point(t),n=Math.max(n>=0?n:r+n,0);n<r;n++)if(this[n].equals(t))return n;return-1}lastIndexOf(t,e=this.length-1){const r=this.length;let n=Number(e);for(t=Point(t),n=n>=0?Math.min(n,r-1):r+n;n>=0;n--)if(this[n].equals(t))return n;return-1}push(...t){return super.push(...t.filter(Grid.isValidHex))}splice(t,e,...r){return null==e?super.splice(t):super.splice(t,e,...r.filter(Grid.isValidHex))}unshift(...t){return super.unshift(...t.filter(Grid.isValidHex))}}const Point$1=PointFactory({ensureXY:ensureXY}),extendHex=extendHexFactory({ensureXY:ensureXY,Point:Point$1}),defineGrid=defineGridFactory({extendHex:extendHex,Grid:Grid,Point:Point$1});export{extendHex,defineGrid,Point$1 as Point};
//# sourceMappingURL=honeycomb.esm.min.js.map
