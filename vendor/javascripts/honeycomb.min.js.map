{"version":3,"file":"honeycomb.min.js","sources":["../node_modules/axis.js/dist/axis.js","../src/utils.js","../src/hex/constants.js","../src/hex/prototype.js","../src/hex/index.js","../src/hex/statics.js","../src/grid/prototype.js","../src/point/index.js","../src/point/prototype.js","../src/grid/class.js","../src/honeycomb.js","../src/grid/index.js","../src/grid/statics.js"],"sourcesContent":["/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.axis = factory();\n  }\n}(this, function () {\n\n  'use strict';\n\n  var axis = {};\n\n  var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' ');\n\n  function type() {\n    return Object.prototype.toString.call(this).slice(8, -1);\n  }\n\n  for (var i = types.length; i--;) {\n    axis['is' + types[i]] = (function (self) {\n      return function (elem) {\n        return type.call(elem) === self;\n      };\n    })(types[i]);\n  }\n\n  return axis;\n\n}));\n","import { isNumber } from 'axis.js'\n\n/**\n * @private\n *\n * @param   {number} offset     The amount to offset (usually -1 or +1).\n * @param   {number} distance   The distance from 0 in a dimension (x, y or q, r).\n *\n * @returns {number}            The amount to offset in the dimension opposite of the passed `distance`.\n */\nexport function offsetFromZero(offset, distance) {\n    return (distance + offset * (distance & 1)) >> 1\n}\n\n/**\n * @private\n *\n * @param   {number} dividend   The amount to get the remainder from after division.\n * @param   {number} divisor    The amount to divide by.\n *\n * @returns {number}            `dividend % divisor`, except negative dividends \"count back from 0\".\n */\nexport function signedModulo(dividend, divisor) {\n    return ((dividend % divisor) + divisor) % divisor\n}\n\n/**\n * @private\n *\n * @param   {string} value              A cardinal/ordinal compass point.\n * @param   {(pointy|flat)} orientation A hex orientation.\n *\n * @returns {(0|1|2|3|4|5)}             The number direction in the range 0..5.\n */\nexport function compassToNumberDirection(value, orientation) {\n    if (!/^(N|S)?(E|W)?$/i.test(value)) {\n        throw new Error(`Invalid compass direction: ${value}. Choose from E, SE, S, SW, W, NW, N or NE.`)\n    }\n\n    orientation = orientation.toLowerCase()\n    value = value.toUpperCase()\n\n    if (orientation === 'pointy' && ['N', 'S'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for pointy hexes. Did you mean ${value}E or ${value}W?`)\n    }\n    if (orientation === 'flat' && ['E', 'W'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for flat hexes. Did you mean N${value} or S${value}?`)\n    }\n\n    /**\n     * There's an (approximate) compass direction for each side of a hex. The right side of a pointy hex has the east (`'E'`) compass direction.\n     * The bottom right side the southeast (`'SE'`) direction, etc. This also means that pointy hexes don't have a north and south compass direction\n     * and flat hexes don't have a west and east compass direction.\n     *\n     * Number directions map to a side of a hex. A pointy hex's right side is `0`, its bottom right side `1`, its bottom left side `2`, etc.\n     * Number directions of flat hexes start at their bottom right side (`0`), their bottom side is `1`, etc.\n     *\n     * @typedef {string} COMPASS_DIRECTION\n     *\n     * @readonly\n     * @enum {COMPASS_DIRECTION}\n     *\n     * @property {COMPASS_DIRECTION} E  → east\n     * @property {COMPASS_DIRECTION} SE ↘ southeast\n     * @property {COMPASS_DIRECTION} S  ↓ south\n     * @property {COMPASS_DIRECTION} SW ↙ southwest\n     * @property {COMPASS_DIRECTION} W  ← west\n     * @property {COMPASS_DIRECTION} NW ↖ northwest\n     * @property {COMPASS_DIRECTION} N  ↑ north\n     * @property {COMPASS_DIRECTION} NE ↗ northeast\n     */\n    return {\n        pointy: { E: 0, SE: 1, SW: 2, W: 3, NW: 4, NE: 5 },\n        flat: { SE: 0, S: 1, SW: 2, NW: 3, N: 4, NE: 5 }\n    }[orientation][value]\n}\n\nexport function ensureXY(x, y) {\n    if (!isNumber(x) && !isNumber(y)) {\n        x = y = 0\n    } else if (!isNumber(x)) {\n        x = y\n    } else if (!isNumber(y)) {\n        y = x\n    }\n\n    return { x, y }\n}\n","/**\n * How rows/columns of hexes are placed relative to each other.\n *\n * An even offset:\n * * places **even rows** of **pointy hexes** half a hex right of the odd rows;\n * * places **even columns** of **flat hexes** half a hex down of the odd rows;\n *\n * An odd offset:\n * * places **odd rows** of **pointy hexes** half a hex right of the even rows;\n * * places **odd columns** of **flat hexes** half a hex down of the even rows;\n *\n * @name OFFSET\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com}\n *\n * @readonly\n * @enum {number}\n *\n * @property {number} even  +1\n * @property {number} odd   -1\n */\n\nexport const DIRECTION_COORDINATES = [\n    { q: 1, r: 0 },\n    { q: 0, r: 1 },\n    { q: -1, r: 1 },\n    { q: -1, r: 0 },\n    { q: 0, r: -1 },\n    { q: 1, r: -1 }\n]\n\nexport const DIAGONAL_DIRECTION_COORDINATES = [\n    { q: 2, r: -1 },\n    { q: 1, r: 1 },\n    { q: -1, r: 2 },\n    { q: -2, r: 1 },\n    { q: -1, r: -1 },\n    { q: 1, r: -2 }\n]\n\nexport const EPSILON = { x: 1e-6, y: 1e-6 }\n","import { EPSILON } from './constants'\nimport { offsetFromZero } from '../utils'\n\nconst sqrt3 = Math.sqrt(3)\n\nexport function setFactory({ Hex }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {*} coordinates   Same parameters as the {@link Hex} factory.\n     * @returns {hex}           Itself with the passed parameters merged into it.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     *\n     * const hex = Hex({ x: 1, y: 2, a: 3, b: 4 })          // { a: 3, b: 4, x: 1, y: 2 }\n     * const updatedHex = hex.set({ x: 0, y: -1, b: 5 })    // { a: 3, b: 5, x: 0, y: -1 }\n     * hex === updatedHex                                   // true: hex is updated in-place\n     */\n    return function set(...args) {\n        return Object.assign(this, Hex(...args))\n    }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().coordinates()      // { x: 0, y: 0 }\n * Hex(1, 2).coordinates()  // { x: 1, y: 2 }\n */\nexport function coordinates() {\n    return { x: this.x, y: this.y }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cube()     // { q: 0, r: 0, s: 0 }\n * Hex(1, 2).cube() // { q: 0, r: 2, s: -2 }\n */\nexport function cube() {\n    return { q: this.q, r: this.r, s: this.s }\n}\n\n/**\n * @memberof Hex#\n *\n * @todo make this a static (and instance?) method\n *\n * @param {Object} cubeCoordinates      At least the `q` and `r` cube coordinates.\n * @param {number} cubeCoordinates.q    The `q` cube coordinate.\n * @param {number} cubeCoordinates.r    The `r` cube coordinate.\n * @param {number} [cubeCoordinates.s]  The optional `s` cube coordinate.\n *\n * @returns {Object}                    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cubeToCartesian({ q: 1, r: 2, s: -3 }) // { x: 2, y: 2 }\n * // the `s` coordinate isn't required:\n * Hex().cubeToCartesian({ q: -3, r: 5 })       // { x: -1, y: 5 }\n */\nexport function cubeToCartesian({ q, r }) {\n    let x, y\n\n    if (this.isPointy()) {\n        x = q + offsetFromZero(this.offset, r)\n        y = r\n    } else {\n        x = q\n        y = r + offsetFromZero(this.offset, q)\n    }\n\n    return { x, y }\n}\n\nexport function cartesianToCubeFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     *\n     * @todo make this a static (and instance?) method\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     * const Point = Honeycomb.Point\n     *\n     * Hex().cartesianToCube(Point(4, -2))      // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube(4, -2)             // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube({ x: 4, y: -2 })   // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube([4, -2])           // { q: 5, r: -2, s: -3 }\n     */\n    return function cartesianToCube(pointOrX, y) {\n        let x, q, r\n\n        ({ x, y } = Point(pointOrX, y))\n\n        if (this.isPointy()) {\n            q = x - offsetFromZero(this.offset, y)\n            r = y\n        } else {\n            q = x\n            r = y - offsetFromZero(this.offset, x)\n        }\n\n        return { q, r, s: -q - r }\n    }\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a pointy ⬢ orientation.\n */\nexport function isPointy() {\n    return this.orientation.toLowerCase() === 'pointy'\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a flat ⬣ orientation.\n */\nexport function isFlat() {\n    return this.orientation.toLowerCase() === 'flat'\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite corners of a hex.\n */\nexport function oppositeCornerDistance() {\n    return this.size * 2\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite sides of a hex.\n */\nexport function oppositeSideDistance() {\n    return sqrt3 / 2 * this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (horizontal) width of a hex.\n */\nexport function width() {\n    return this.isPointy() ?\n        this.oppositeSideDistance() :\n        this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (vertical) height of a hex.\n */\nexport function height() {\n    return this.isPointy() ?\n        this.oppositeCornerDistance() :\n        this.oppositeSideDistance()\n}\n\nexport function cornersFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point[]}\n     * Array of corner points relative to the {@link Hex#origin|hex's origin}.\n     * Starting at the top right corner for pointy hexes and the right corner for flat hexes.\n     *\n     * @example\n     * // a hex's origin defaults to its top left corner (as if it's a rectangle)\n     * const Hex1 = Honeycomb.extendHex({ size: 30 })\n     * Hex1().corners() // [\n     *                  //    { x: 51.96152422706631, y: 15 },\n     *                  //    { x: 51.96152422706631, y: 45 },\n     *                  //    { x: 25.980762113533157, y: 60 },\n     *                  //    { x: 0, y: 45 },\n     *                  //    { x: 0, y: 15 },\n     *                  //    { x: 25.980762113533157, y: 0 }\n     *                  // ]\n     *\n     * // set the origin to a hex's center\n     * const Hex2 = Honeycomb.extendHex({ size: 30, origin: [25.980762113533157, 30] })\n     * Hex2().corners() // [\n     *                  //    { x: 25.980762113533157, y: -15 },\n     *                  //    { x: 25.980762113533157, y: 15 },\n     *                  //    { x: 0, y: 30 },\n     *                  //    { x: -25.980762113533157, y: 15 },\n     *                  //    { x: -25.980762113533157, y: -15 },\n     *                  //    { x: 0, y: -30 }\n     *                  // ]\n     */\n    return function corners() {\n        const width = this.width()\n        const height = this.height()\n        const { x, y } = this.origin\n\n        if (this.isPointy()) {\n            return [\n                Point(width - x, height * 0.25 - y),\n                Point(width - x, height * 0.75 - y),\n                Point(width * 0.5 - x, height - y),\n                Point(0 - x, height * 0.75 - y),\n                Point(0 - x, height * 0.25 - y),\n                Point(width * 0.5 - x, 0 - y)\n            ]\n        } else {\n            return [\n                Point(width - x, height * 0.5 - y),\n                Point(width * 0.75 - x, height - y),\n                Point(width * 0.25 - x, height - y),\n                Point(0 - x, height * 0.5 - y),\n                Point(width * 0.25 - x, 0 - y),\n                Point(width * 0.75 - x, 0 - y)\n            ]\n        }\n    }\n}\n\nexport function centerFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} Point relative to the {@link Hex#origin|hex's origin}.\n     * Note that the default origin is the top left corner, so the default center is\n     * `{ x: hexWidth / 2, y: hexHeight / 2 }`.\n     *\n     * @example\n     * const Hex1 = Honeycomb.extendHex({ size: 10 })\n     * Hex1().center()  // { x: 8.660254037844386, y: 10 }\n     *\n     * const Hex2 = Honeycomb.extendHex({ size: 10, origin: [5, 5] })\n     * Hex2().center()  // { x: 3.6602540378443855, y: 5 }\n     */\n    return function center() {\n        const { x, y } = this.origin\n        return Point(this.width() / 2 - x, this.height() / 2 - y)\n    }\n}\n\nexport function toPointFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} The hex's origin point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 30 })\n     * Hex().toPoint()          // { x: 0, y: 0 }\n     * Hex(-2, -5).toPoint()    // { x: -77.94228634059947, y: -225 }\n     */\n    return function toPoint() {\n        const { q, r, size } = this\n        let x, y\n\n        if (this.isPointy()) {\n            x = size * sqrt3 * (q + r / 2)\n            y = size * 3/2 * r\n        } else {\n            x = size * 3/2 * q\n            y = size * sqrt3 * (r + q / 2)\n        }\n\n        return Point(x, y)\n    }\n}\n\nexport function fromPointFactory({ Point, Hex }) {\n    /**\n     * Returns a hex from the passed {@link point}.\n     *\n     * @memberof Hex\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#pixel-to-hex|redblobgames.com}\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 50 })\n     * const Point = Honeycomb.Point\n     * const hex = Hex()\n     *\n     * hex.fromPoint(Point(120, 280))     // { x: 0, y: 3 }\n     * hex.fromPoint(120, 280)            // { x: 0, y: 3 }\n     * hex.fromPoint({ x: 120, y: 280 })  // { x: 0, y: 3 }\n     * hex.fromPoint([ 120, 280 ])        // { x: 0, y: 3 }\n     */\n    return function fromPoint(pointOrX, y) {\n        const { size } = this\n        let x, q, r\n\n        ({ x, y } = Point(pointOrX, y).subtract(this.center()))\n\n        if (this.isPointy()) {\n            q = (x * sqrt3 / 3 - y / 3) / size\n            r = y * 2 / 3 / size\n        } else {\n            q = x * 2 / 3 / size\n            r = (-x / 3 + sqrt3 / 3 * y) / size\n        }\n\n        return Hex({ q, r, s: -q - r }).round()\n    }\n}\n\nexport function addFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to add.\n     *\n     * @param {point} point The hex (or point) that will be added to the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are added to the current.\n     *                      Any custom properties are copied.\n     */\n    return function add(point) {\n        const { x, y } = Point(point)\n        return Hex(this.x + x, this.y + y, {...this})\n    }\n}\n\nexport function subtractFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to subtract.\n     *\n     * @param {point} point The hex (or point) that will be subtracted from the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are subtracted from the current.\n     *                      Any custom properties are copied.\n     */\n    return function subtract(point) {\n        const { x, y } = Point(point)\n        return Hex(this.x - x, this.y - y, {...this})\n    }\n}\n\nexport function equalsFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {point} point The hex (or point) whose coordinates will be compared against the current hex.\n     * @returns {boolean}   Whether the coordinates of the current and the passed point are equal.\n     */\n    return function equals(point) {\n        const { x, y } = Point(point)\n        return this.x === x && this.y === y\n    }\n}\n\n/**\n * @memberof Hex#\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#distances|redblobgames.com}\n *\n * @param   {hex} hex   The last hex (cannot be a {@link point}).\n * @returns {number}    The amount of hexes from the current to (and excluding) the last hex.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().distance(Hex(1, 0))        // 1\n * Hex(-2, -2).distance(Hex(4, 1))  // 8\n */\nexport function distance(hex) {\n    return Math.max(\n        Math.abs(this.q - hex.q),\n        Math.abs(this.r - hex.r),\n        Math.abs(this.s - hex.s)\n    )\n}\n\nexport function roundFactory({ Hex }) {\n    /**\n     * Rounds the current floating point hex coordinates to their nearest integer hex coordinates.\n     *\n     * @memberof Hex#\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#rounding|redblobgames.com}\n     *\n     * @returns {hex}   A *new* hex with rounded coordinates.\n     *                  Any custom properties are copied.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     * Hex(3.1415, 0.5).round() // { x: 3, y: 1 }\n     */\n    return function round() {\n        let { q, r, s } = this\n        let roundedQ = Math.round(q)\n        let roundedR = Math.round(r)\n        let roundedS = Math.round(s)\n        const diffQ = Math.abs(q - roundedQ)\n        const diffR = Math.abs(r - roundedR)\n        const diffS = Math.abs(s - roundedS)\n\n        if (diffQ > diffR && diffQ > diffS) {\n            roundedQ = -roundedR - roundedS\n        } else if (diffR > diffS) {\n            roundedR = -roundedQ - roundedS\n        } else {\n            roundedS = -roundedQ - roundedR\n        }\n\n        return Hex({ ...this, q: roundedQ, r: roundedR, s: roundedS })\n    }\n}\n\nexport function lerpFactory({ Hex }) {\n    /**\n     * Returns an interpolation between the current hex and the passed hex for a `t` between 0 and 1.\n     * More info on [wikipedia](https://en.wikipedia.org/wiki/Linear_interpolation).\n     *\n     * @memberof Hex#\n     *\n     * @param   {hex} hex   The other hex (cannot be a {@link point}).\n     * @param   {number} t  A \"parameter\" between 0 and 1.\n     *\n     * @returns {hex}       A new hex (likely with floating point coordinates).\n     *                      Any custom properties are copied.\n     */\n    return function lerp(hex, t) {\n        const q = this.q * (1 - t) + hex.q * t\n        const r = this.r * (1 - t) + hex.r * t\n        return Hex({ ...this, q, r, s: -q - r })\n    }\n}\n\n/**\n * @memberof Hex#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @returns {hex}   A *new* hex with a tiny offset from the current hex.\n *                  Useful for interpolating in a consistent direction.\n */\nexport function nudge() {\n    return this.add(EPSILON)\n}\n\n/**\n * @memberof Hex#\n * @returns {string}    A string representation of the hex.\n */\nexport function toString() {\n    return `${this.x},${this.y}`\n}\n","import { isObject, isNumber, isArray } from 'axis.js'\n\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nexport const staticMethods = {\n    thirdCoordinate: statics.thirdCoordinate\n}\n\nexport default function extendHexFactory({ ensureXY, Point }) {\n    /**\n     * @function extendHex\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create custom hexes by extending the default Hex prototype.\n     *\n     * All properties of the object passed to `extendHex()` will be added to the prototype of the resulting {@link Hex} factory.\n     * To add properties to individual hexes (instances), pass them to the {@link Hex} factory.\n     *\n     * @todo validate orientation, size, origin\n     * @todo warn when properties are overriden\n     *\n     * @param {Object} [prototype={}]   An object that's used as the prototype for all hexes in a grid.\n     *                                  **Warning:** properties in this object will overwrite properties with the same name in the default prototype.\n     *\n     * @returns {Hex}                   A function to produce hexes that are all linked to the same prototype.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({\n     *     size: 50,\n     *     orientation: 'flat',\n     *     customProperty: `I'm custom 😃`,\n     *     customMethod() {\n     *         return `${this.customProperty} and called from a custom method 😎`\n     *     }\n     * })\n     * const hex = Hex(5, -1)\n     *\n     * hex.coordinates()    // { x: 5, y: -1 }\n     * hex.size             // 50\n     * hex.customProperty   // I'm custom 😃\n     * hex.customMethod()   // I'm custom 😃 and called from a custom method 😎\n     *\n     * // every hex created with Hex() shares these properties:\n     * const hex2 = Hex(3, 0)\n     * hex2.size            // 50\n     * hex2.customProperty  // I'm custom 😃\n     *\n     * // to set properties on individual hexes, pass them to Hex():\n     * const hex3 = Hex(-2, -1, { instanceProperty: `I'm a unique snowflake 😌` })\n     * hex3.instanceProperty    // I'm a unique snowflake 😌\n     */\n    return function extendHex(prototype = {}) {\n        const cartesianToCube = methods.cartesianToCubeFactory({ Point })\n        const defaultPrototype = {\n            /**\n             * Used internally for type checking\n             *\n             * @memberof Hex#\n             * @private\n             */\n            __isHoneycombHex: true,\n            /**\n             * Either ⬢ pointy or ⬣ flat. Defaults to `pointy`.\n             *\n             * @memberof Hex#\n             * @type {string}\n             * @default 'pointy'\n             */\n            orientation: 'pointy',\n            /**\n             * Distance from a hex's top left corner (as if it were a rectange). Defaults to `Point(0)`.\n             * Can be anything the {@link Honeycomb.Point} factory accepts.\n             * When a {@link Hex#toPoint|hex is converted to a point}, it is converted to this origin.\n             *\n             * @memberof Hex#\n             * @type {point}\n             * @default 0\n             */\n            origin: 0,\n            /**\n             * A hex's radius or the length of any of its sides. Defaults to `1`.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default 1\n             */\n            size: 1,\n            /**\n             * Used to calculate the coordinates of rows for pointy hexes and columns for flat hexes.\n             * Defaults to `-1` (odd offset).\n             * See {@link OFFSET} for details.\n             * See {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com} why this is needed.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default -1\n             * @see OFFSET\n             */\n            offset: -1,\n            /**\n             * Getter for `q` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get q() { return this.cartesianToCube(this).q },\n            /**\n             * Getter for `r` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get r() { return this.cartesianToCube(this).r },\n            /**\n             * Getter for `s` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get s() { return this.cartesianToCube(this).s },\n\n            // methods:\n            add: methods.addFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#coordinates}.\n             * @memberof Hex#\n             * @instance\n             */\n            cartesian: methods.coordinates,\n            cartesianToCube,\n            center: methods.centerFactory({ Point }),\n            coordinates: methods.coordinates,\n            corners: methods.cornersFactory({ Point }),\n            cube: methods.cube,\n            cubeToCartesian: methods.cubeToCartesian,\n            distance: methods.distance,\n            equals: methods.equalsFactory({ Point }),\n            fromPoint: methods.fromPointFactory({ Point, Hex }),\n            height: methods.height,\n            isFlat: methods.isFlat,\n            isPointy: methods.isPointy,\n            lerp: methods.lerpFactory({ Hex }),\n            nudge: methods.nudge,\n            oppositeCornerDistance: methods.oppositeCornerDistance,\n            oppositeSideDistance: methods.oppositeSideDistance,\n            round: methods.roundFactory({ Hex }),\n            set: methods.setFactory({ Hex }),\n            subtract: methods.subtractFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#cubeToCartesian}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCartesian: methods.cubeToCartesian,\n            /**\n             * Alias for {@link Hex#cartesianToCube}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCube: cartesianToCube,\n            toPoint: methods.toPointFactory({ Point }),\n            toString: methods.toString,\n            width: methods.width\n        }\n        const finalPrototype = Object.assign(defaultPrototype, prototype)\n\n        // ensure origin is a point\n        finalPrototype.origin = Point(finalPrototype.origin)\n\n        Object.assign(Hex, staticMethods)\n\n        /**\n         * @function Hex\n         *\n         * @description\n         * Factory function to create hexes. Use {@link Honeycomb.extendHex} to create a Hex factory.\n         *\n         * @see {@link redblobgames.com|https://www.redblobgames.com/grids/hexagons/#coordinates}\n         *\n         * @param {(number|Object|number[])} [xOrProps=]    The x coordinate,\n         *                                                  **or** an object containing *any* of the cartesian (`x` and `y`) coordinates and optional custom properties,\n         *                                                  **or** an object containing *all* of the cube (`q`, `r`, and `s`) coordinates and optional custom properties,\n         *                                                  **or** an array containing *any* of the cartesian (x and y) coordinates.\n         * @param {number} [xOrProps.x=]                    The x coordinate.\n         * @param {number} [xOrProps.y=]                    The y coordinate.\n         * @param {number} [y=]                             The y coordinate.\n         * @param {object} [customProps={}]                 Any custom properties. The coordinates are merged into this object, ignoring any coordinates present in `customProps`.\n         *\n         * @returns {hex}                                   A hex. It *always* contains *only* the cartesian (x and y) coordinates and any custom properties.\n         *\n         * @example\n         * const Hex = Honeycomb.extendHex()\n         *\n         * // passing numbers:\n         * Hex()                        // { x: 0, y: 0 }\n         * Hex(1)                       // { x: 1, y: 1 }\n         * Hex(1, 2)                    // { x: 1, y: 2 }\n         *\n         * // passing an object with cartesian coordinates:\n         * Hex({})                      // { x: 0, y: 0 }\n         * Hex({ x: 1 })                // { x: 1, y: 1 }\n         * Hex({ y: 2 })                // { x: 2, y: 2 }\n         * Hex({ x: 1, y: 2 })          // { x: 1, y: 2 }\n         *\n         * // passing an object with cube coordinates:\n         * Hex({ q: 1, r: 2, s: -3 })   // { x: 2, y: 2 }\n         * Hex({ q: 1 })                // throws an error because of missing cube coordinates\n         *\n         * // passing an array:\n         * Hex([])                      // { x: 0, y: 0 }\n         * Hex([1])                     // { x: 1, y: 1 }\n         * Hex([1, 2])                  // { x: 1, y: 2 }\n         *\n         * // custom properties:\n         * Hex(1, 2, { a: 3 })          // { a: 3, x: 1, y: 2 }\n         * Hex({ x: 1, y: 2, a: 3 })    // { a: 3, x: 1, y: 2 }\n         *\n         * // cloning a hex:\n         * const someHex = Hex(4, -2)   // { x: 4, y: -2 }\n         * const clone = Hex(someHex)   // { x: 4, y: -2 }\n         * someHex === clone            // false\n         */\n        function Hex(xOrProps, y, customProps = {}) {\n            let x\n\n            if (isObject(xOrProps)) {\n                let { q, r, s, ...rest } = xOrProps\n\n                if (isNumber(q) || isNumber(r) || isNumber(s)) {\n                    if (q + r + s !== 0) {\n                        throw new Error(`Cube coordinates must have a sum of 0. q: ${q}, r: ${r}, s: ${s}, sum: ${q + r + s}.`)\n                    }\n\n                    ({ x, y } = finalPrototype.cubeToCartesian({ q, r, s }))\n                } else {\n                    ({ x, y } = xOrProps)\n                }\n\n                customProps = rest\n            } else if (isArray(xOrProps)) {\n                [x, y] = xOrProps\n                // ignore all arguments except xOrProps\n                customProps = {}\n            } else {\n                x = xOrProps\n            }\n\n            /**\n             * An object with x and y properties and several methods in its prototype chain, created by a {@link Hex} factory.\n             *\n             * @typedef {Object} hex\n             * @property {number} x Cartesian x coordinate.\n             * @property {number} y Cartesian y coordinate.\n             */\n            return Object.assign(\n                // the prototype has to be attached here, else Grid's shape methods break 🙁\n                Object.create(finalPrototype),\n                Object.assign(customProps, ensureXY(x, y))\n            )\n        }\n\n        return Hex\n    }\n}\n","/**\n * Calculates the third cube coordinate from the other two. The sum of all three coordinates must be 0.\n *\n * @memberof Hex\n * @static\n *\n * @param {number} firstCoordinate  The first other cube coordinate.\n * @param {number} secondCoordinate The second other cube coordinate.\n *\n * @returns {number}                The third cube coordinate.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n * Hex.thirdCoordinate(3, -2)   // -1\n */\nexport function thirdCoordinate(firstCoordinate, secondCoordinate) {\n    return -firstCoordinate - secondCoordinate\n}\n","import { isString, isNumber } from 'axis.js'\n\nimport { DIRECTION_COORDINATES, DIAGONAL_DIRECTION_COORDINATES } from '../hex/constants'\n\n/**\n * Get a hex from a grid.\n *\n * @memberof Grid#\n * @instance\n *\n * @param {(number|point)} keyOrPoint   An index/key or a point.\n * @returns {hex}                       The found hex or `undefined`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 2, height: 2 })\n *\n * grid.get(0)              // { x: 0, y: 0 }\n * grid.get(Hex(0, 1))      // { x: 0, y: 1 }\n * grid.get({ x: 0, y: 1 }) // { x: 0, y: 1 }\n * grid.get([0, 1])         // { x: 0, y: 1 }\n *\n * grid.get(42)             // undefined\n * grid.get(Hex(6, -2))     // undefined\n */\nexport function get(keyOrPoint) {\n    if (isNumber(keyOrPoint)) {\n        return this[keyOrPoint]\n    } else {\n        return this[this.indexOf(keyOrPoint)]\n    }\n}\n\nexport function setFactory({ isValidHex }) {\n    /**\n     * Replace a hex with another hex. This is a safe alternative to using bracket notation (`grid[0] = 'invalid'`).\n     *\n     * If the target hex isn't present in the grid, the new hex is added (using {@link Grid#push}) to the grid.\n     * If the new hex is invalid, nothing changes.\n     *\n     * @memberof Grid#\n     * @instance\n     *\n     * @param {(number|point)} keyOrPoint   The coordinates of the hex that must be replaced.\n     * @param {hex} newHex                  The replacing hex.\n     *\n     * @returns {grid}                      Itself.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0, 0)) // [ { x: 0, y: 0 } ]\n     *\n     * // replace a hex:\n     * grid.set(0, Hex(1, 1))\n     * grid                         // [ { x: 1, y: 1 } ]\n     * // the target hex can also be a point:\n     * grid.set([1, 1], Hex(2, 2))\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // invalid replace values are ignored:\n     * grid.set(0, 'invalid')\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // when the target hex isn't present in the grid, the replacing hex is added instead:\n     * grid.set({ x: 9, y: 9 }, Hex(3, 3))\n     * grid                         // [ { x: 2, y: 2 }, { x: 3, y: 3 } ]\n     */\n    return function set(keyOrPoint, newHex) {\n        if (!isValidHex(newHex)) {\n            return this\n        }\n\n        const index = isNumber(keyOrPoint) ? keyOrPoint : this.indexOf(keyOrPoint)\n\n        if (index < 0) {\n            this.push(newHex)\n        } else {\n            this[index] = newHex\n        }\n\n        return this\n    }\n}\n\n/**\n * @memberof Grid#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @param {hex} firstHex    The first hex.\n * @param {hex} lastHex     The last hex.\n *\n * @returns {hex[]}         Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 4, height: 4 })\n *\n * grid.hexesBetween(Hex(), Hex(3)) // [\n *                                  //    { x: 0, y: 0 },\n *                                  //    { x: 0, y: 1 },\n *                                  //    { x: 1, y: 1 },\n *                                  //    { x: 2, y: 2 },\n *                                  //    { x: 3, y: 2 },\n *                                  //    { x: 3, y: 3 },\n *                                  // ]\n */\nexport function hexesBetween(firstHex, lastHex) {\n    const distance = firstHex.distance(lastHex)\n    const step = 1.0 / Math.max(distance, 1)\n    let hexes = []\n\n    for (let i = 0; i <= distance; i++) {\n        const hex = firstHex.nudge().lerp(lastHex.nudge(), step * i).round()\n        hexes.push(this.get(hex))\n    }\n\n    return hexes\n}\n\nexport function hexesInRangeFactory({ isValidHex }) {\n    /**\n     * @memberof Grid#\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#range-coordinate|redblobgames.com}\n     *\n     * @param {hex} centerHex                   A hex to get surrounding hexes from.\n     * @param {number} [range=0]                The range (in hexes) surrounding the center hex.\n     * @param {boolean} [includeCenterHex=true] Whether to include the center hex in the result\n     *\n     * @returns {hex[]}             An array with all hexes surrounding the passed center hex.\n     *                              Only hexes that are present in the grid are returned.\n     *\n     * @throws {Error} When no valid hex is passed.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * const grid = Grid.rectangle({ width: 5, height: 5 })\n     *\n     * grid.hexesInRange(Hex(2, 2), 2)          // [\n     *                                          //    { x: 0, y: 2 },\n     *                                          //    { x: 0, y: 3 },\n     *                                          //    { x: 1, y: 4 },\n     *                                          //    ...\n     *                                          //    { x: 3, y: 0 },\n     *                                          //    { x: 3, y: 1 },\n     *                                          //    { x: 4, y: 2 }\n     *                                          // ]\n     *\n     * // only returns hexes that exist in the grid:\n     * grid.hexesInRange(Hex(0, 0), 1)          // [\n     *                                          //    { x: 0, y: 0 },\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: 1, y: 0 }\n     *                                          // ]\n     *\n     * // exclude center hex:\n     * grid.hexesInRange(Hex(2, 2), 1, false)   // [\n     *                                          //    { x: 1, y: 2 },\n     *                                          //    { x: 1, y: 3 },\n     *                                          //    { x: 1, y: 1 },\n     *                                          //    { x: 2, y: 3 },\n     *                                          //    { x: 3, y: 2 }\n     *                                          // ]\n     */\n    return function hexesInRange(centerHex, range = 0, includeCenterHex = true) {\n        if (!isValidHex(centerHex)) {\n            throw new Error(`Invalid center hex: ${centerHex}.`)\n        }\n\n        if (!this.get(centerHex)) {\n            throw new Error(`Center hex with coordinates ${centerHex} not present in grid.`)\n        }\n\n        let hexes = []\n\n        for (let q = -range; q <= range; q++) {\n            for (let r = Math.max(-range, -q - range); r <= Math.min(range, -q + range); r++) {\n                const hex = this.get(centerHex.cubeToCartesian({ q: centerHex.q + q, r: centerHex.r + r }))\n\n                if (centerHex.equals(hex) && !includeCenterHex) {\n                    continue\n                }\n\n                hexes.push(hex)\n            }\n        }\n\n        return hexes.filter(Boolean)\n    }\n}\n\nexport function neighborsOfFactory({ isValidHex, signedModulo, compassToNumberDirection }) {\n    /**\n     * @memberof Grid#\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#neighbors|redblobgames.com}\n     *\n     * @param {hex} hex\n     * A hex to get 1 or more neighbors from.\n     * @param {((COMPASS_DIRECTION|number)[]|COMPASS_DIRECTION|number|all)} [directions=all]\n     * 1 or more directions. Either (an array of) {@link COMPASS_DIRECTION|compass directions} or numbers or the string `'all'`.\n     * @param {boolean} [diagonal=false]\n     * Whether to get the diagonal neighbor. See {@link https://www.redblobgames.com/grids/hexagons/#neighbors-diagonal|redblobgames.com}.\n     *\n     * @returns {hex[]}\n     * An array of 0 up to 6 neighboring hexes. Only hexes that are present in the grid are returned.\n     *\n     * @throws {Error} When no valid hex is passed.\n     * @throws {Error} When the direction is invalid for the hex.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * // conveniently creates a grid consisting of a hex surrounded by 6 hexes:\n     * const grid = Grid.hexagon({ radius: 1 })\n     *\n     * // all neighbors:\n     * grid.neighborsOf(Hex())          // [\n     *                                  //    { x: 1, y: 0 },\n     *                                  //    { x: 0, y: 1 },\n     *                                  //    { x: -1, y: 1 },\n     *                                  //    { x: -1, y: 0 },\n     *                                  //    { x: -1, y: -1 },\n     *                                  //    { x: 0, y: -1 },\n     *                                  // ]\n     * // specific neighbor:\n     * grid.neighborsOf(Hex(), 'NW')    // [{ x: -1, y: -1 }]\n     * grid.neighborsOf(Hex(), 4)       // [{ x: -1, y: -1 }]\n     *\n     * // multiple neighbors:\n     * grid.neighborsOf(Hex(), ['SE', 'SW'])    // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     *\n     * grid.neighborsOf(Hex(), [1, 2])          // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     * // diagonal neighbor:\n     * grid.neighborsOf(Hex(-1, 0), 'E', true)  // [{ x: 0, y: -1 }]\n     *\n     * // only returns hexes that exist in the grid:\n     * grid.neighborsOf(Hex(-1, -1), 'NW')      // []\n     */\n    return function neighborsOf(hex, directions = 'all', diagonal = false) {\n        if (!isValidHex(hex)) {\n            throw new Error(`Invalid hex: ${hex}.`)\n        }\n\n        const coordinates = diagonal ? DIAGONAL_DIRECTION_COORDINATES : DIRECTION_COORDINATES\n\n        if (directions === 'all') {\n            directions = [0, 1, 2, 3, 4, 5]\n        }\n\n        return directions = []\n            // ensure directions is an array\n            .concat(directions)\n            .map(direction => {\n                // todo: move this to a util, also grid/statics.js#277\n                if (isString(direction)) {\n                    direction = compassToNumberDirection(direction, hex.orientation)\n                }\n\n                if (direction < 0 || direction > 5) {\n                    direction = signedModulo(direction, 6)\n                }\n\n                const { q, r } = coordinates[direction]\n                return this.get(hex.cubeToCartesian({ q: hex.q + q, r: hex.r + r }))\n            })\n            .filter(Boolean)\n    }\n}\n","import { isNumber, isArray, isObject } from 'axis.js'\nimport * as methods from './prototype'\n\n/**\n * See {@link Point}.\n *\n * @function Point\n * @memberof Honeycomb\n * @static\n */\n\nexport default function PointFactory({ ensureXY }) {\n    const prototype = {\n        add: methods.addFactory({ Point }),\n        subtract: methods.subtractFactory({ Point }),\n        multiply: methods.multiplyFactory({ Point }),\n        divide: methods.divideFactory({ Point })\n    }\n\n    /**\n     * Factory function for creating two-dimensional points.\n     *\n     * @function Point\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}                             A point.\n     *\n     * @example\n     * const Point = Honeycomb.Point\n     *\n     * Point()                  // { x: 0, y: 0 }\n     * Point(1)                 // { x: 1, y: 1 }\n     * Point(1, 2)              // { x: 1, y: 2 }\n     *\n     * Point([])                // { x: 0, y: 0 }\n     * Point([1])               // { x: 1, y: 1 }\n     * Point([1, 2])            // { x: 1, y: 2 }\n     *\n     * Point({})                // { x: 0, y: 0 }\n     * Point({ x: 1 })          // { x: 1, y: 1 }\n     * Point({ y: 2 })          // { x: 2, y: 2 }\n     * Point({ x: 1, y: 2 })    // { x: 1, y: 2 }\n     */\n    function Point(pointOrX, y) {\n        let coordinates\n        /**\n         * An object with just an `x` and a `y` property.\n         *\n         * Create your own:\n         * ```javascript\n         * const point = { x: 1, y: 2 }\n         * ```\n         *\n         * Or use the included {@link Point} factory:\n         * ```javascript\n         * const point = Honeycomb.Point(1, 2)\n         * ```\n         *\n         * @typedef {Object} point\n         * @property {number} x (horizontal) x coordinate\n         * @property {number} y (vertical) y coordinate\n         */\n\n        if (isNumber(pointOrX)) {\n            coordinates = ensureXY(pointOrX, y)\n        } else if (isArray(pointOrX)) {\n            coordinates = ensureXY(...pointOrX)\n        } else if (isObject(pointOrX)) {\n            coordinates = ensureXY(pointOrX.x, pointOrX.y)\n        } else {\n            coordinates = ensureXY(0)\n        }\n\n        return Object.assign(\n            Object.create(prototype),\n            coordinates\n        )\n    }\n\n    return Point\n}\n","export function addFactory({ Point }) {\n    /**\n     * @memberof Point#\n\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The sum of the passed point's coordinates to the current point's.\n     */\n    return function add(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x + x, this.y + y)\n    }\n}\n\nexport function subtractFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The difference between the passed point's coordinates and the current point's.\n     */\n    return function subtract(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x - x, this.y - y)\n    }\n}\n\nexport function multiplyFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The multiplication of the passed point's coordinates and the current point's.\n     */\n    return function multiply(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x * x, this.y * y)\n    }\n}\n\nexport function divideFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The division of the current point's coordinates and the passed point's.\n     */\n    return function divide(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x / x, this.y / y)\n    }\n}\n","import { ensureXY } from '../utils'\nimport PointFactory from '../point'\n\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @private\n *\n * The only way to prevent setting invalid items in a grid (`grid[0] = 'not a hex'`) is by using proxies.\n * A proxy can have a `set` trap that can prevent the setting of invalid hexes.\n *\n * Some approaches include:\n * 1. Wrapping the grid instance returned from GridFactory in a proxy.\n * 2. Putting a proxy in the prototype chain of Grid (this \"shields\" the Array prototype methods).\n * 3. Using a proxy to forward certain calls to the Array prototype (and not extending Array at all).\n */\n\nexport default class Grid extends Array {\n    /**\n     * @private\n     * @param {*} value     Any value.\n     * @returns {boolean}   Whether the passed value is a valid hex.\n     */\n    static isValidHex(value) {\n        return (value || {}).__isHoneycombHex === true\n    }\n\n    /**\n     * @memberof Grid#\n     * @override\n     * @throws {TypeError}  It makes no sense for a grid to fill it with arbitrary values, because it should only contain valid hexes.\n     *\n     * @returns {TypeError} An error.\n     */\n    fill() {\n        throw new TypeError('Grid.prototype.fill is not implemented')\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|Array#includes},\n     * but searches the passed hex (which can also be a {@link point}.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *\n     * @returns {boolean}               Whether the hex is included in the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0))    // [ { x: 0, y: 0 } ]\n     *\n     * grid.includes(Hex(0))        // true\n     * grid.includes([0, 0])        // true\n     * grid.includes(Hex(0), 1)     // false\n     * grid.includes(Hex(5, 7))     // false\n     */\n    includes(point, fromIndex = 0) {\n        return !!(this.indexOf(point, fromIndex) + 1)\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array#indexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *                                  If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                The index of the found hex (first from the left) or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.indexOf(Hex(0))     // 0\n     * grid.indexOf([0, 0])     // 0\n     * grid.indexOf(Hex(0), 1)  // 2\n     * grid.indexOf(Hex(5, 7))  // -1\n     */\n    indexOf(point, fromIndex = 0) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = Math.max(i >= 0 ? i : length + i, 0)\n\n        for (i; i < length; i++) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|Array#lastIndexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * Because all hexes will have different coordinates in most grids, this method behaves the same as {@link Grid#indexOf}.\n     * This method might have a slightly better performance if you know the search hex is at the end of the grid.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point                 The coordinates to search for.\n     * @param {number} [fromIndex=length-1] Optional index to start searching back from.\n     *                                      If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                    The last index of the found hex or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.lastIndexOf(Hex(0))     // 2\n     * grid.lastIndexOf([0, 0])     // 2\n     * grid.lastIndexOf(Hex(0), 1)  // 0\n     * grid.lastIndexOf(Hex(5, 7))  // -1\n     */\n    lastIndexOf(point, fromIndex = this.length - 1) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = i >= 0 ? Math.min(i, length - 1) : length + i\n\n        for (i; i >= 0; i--) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push|Array#push},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the end of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.push(Hex(1))            // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.push('invalid')         // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     */\n    push(...hexes) {\n        return super.push(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice|Array#splice},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {number} start                        Index at which to start changing the grid.\n     * @param {number} [deleteCount=length-start]   Amount of hexes to delete.\n     * @param {...hex} [hexes=[]]                   The hexes to add to the grid, beginning at the `start`.\n     *\n     * @returns {hex[]}                             A grid with the deleted hexes (if any).\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid.rectangle({ width: 2, height: 1 })\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 0, y: 1 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     *\n     * grid.splice(2)               // [{ x: 0, y: 1 }, { x: 1, y: 1 }] <- deleted hexes\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }] <- leftover hexes\n     *\n     * grid.splice(2, 1)            // [{ x: 0, y: 1 }]\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.splice(2, 1, Hex(2))    // [{ x: 0, y: 1 }]\n     * grid\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 2, y: 2 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     */\n    splice(start, deleteCount, ...hexes) {\n        // when deleteCount is undefined/null, it's casted to 0, deleting 0 hexes\n        // this is not according to spec: it should delete all hexes (starting from `start`)\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        if (deleteCount == null) {\n            return super.splice(start)\n        }\n\n        return super.splice(start, deleteCount, ...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift|Array#unshift},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the start of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.unshift(Hex(1))         // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     *\n     * grid.unshift('invalid')      // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     */\n    unshift(...hexes) {\n        return super.unshift(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat|Array#concat}.\n     * @memberof Grid#\n     * @method concat\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin|Array#copyWithin}.\n     * @memberof Grid#\n     * @method copyWithin\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries|Array#entries}.\n     * @memberof Grid#\n     * @method entries\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every|Array#every}.\n     * @memberof Grid#\n     * @method every\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter|Array#filter}.\n     * @memberof Grid#\n     * @method filter\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find|Array#find}.\n     * @memberof Grid#\n     * @method find\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex|Array#findIndex}.\n     * @memberof Grid#\n     * @method findIndex\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach|Array#forEach}.\n     * @memberof Grid#\n     * @method forEach\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join|Array#join}.\n     * @memberof Grid#\n     * @method join\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys|Array#keys}.\n     * @memberof Grid#\n     * @method keys\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map|Array#map}.\n     * @memberof Grid#\n     * @method map\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop|Array#pop}.\n     * @memberof Grid#\n     * @method pop\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce|Array#reduce}.\n     * @memberof Grid#\n     * @method reduce\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight|Array#reduceRight}.\n     * @memberof Grid#\n     * @method reduceRight\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse|Array#reverse}.\n     * @memberof Grid#\n     * @method reverse\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift|Array#shift}.\n     * @memberof Grid#\n     * @method shift\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some|Array#some}.\n     * @memberof Grid#\n     * @method some\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort|Array#sort}.\n     * @memberof Grid#\n     * @method sort\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString|Array#toLocaleString}.\n     * @memberof Grid#\n     * @method toLocaleString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString|Array#toString}.\n     * @memberof Grid#\n     * @method toString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values|Array#values}.\n     * @memberof Grid#\n     * @method values\n     * @instance\n     */\n}\n","import { ensureXY } from './utils'\nimport extendHexFactory from './hex'\nimport defineGridFactory from './grid'\nimport Grid from './grid/class'\nimport PointFactory from './point'\n\nconst Point = PointFactory({ ensureXY })\nconst extendHex = extendHexFactory({ ensureXY, Point })\nconst defineGrid = defineGridFactory({ extendHex, Grid, Point })\n\n/**\n * @namespace {Object} Honeycomb\n */\nexport {\n    extendHex,\n    defineGrid,\n    Point\n}\n","import { isArray } from 'axis.js'\n\nimport { signedModulo, compassToNumberDirection } from '../utils'\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nexport default function defineGridFactory({ extendHex, Grid, Point }) {\n    const { isValidHex } = Grid\n\n    /**\n     * @function defineGrid\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create {@link Grid} factories by passing it a {@link Hex} factory.\n     *\n     * @param {Hex} [Hex=Honeycomb.extendHex()] A {@link Hex} factory.\n     *                                          If nothing is passed, the default Hex factory is used by calling `Honeycomb.extendHex()` internally.\n     *\n     * @returns {Grid}                          A Grid factory.\n     *\n     * @example\n     * // create a Grid factory that uses the default Hex Factory:\n     * const Grid = Honeycomb.defineGrid()\n     * const hex = Grid.Hex()\n     * hex.size     // 1\n     *\n     * // create your own Hex factory\n     * const CustomHex = Honeycomb.extendHex({ size: 10, custom: '🤓' })\n     * // …and pass it to defineGrid() to create a Grid factory that produces your custom hexes\n     * const CustomGrid = Honeycomb.defineGrid(CustomHex)\n     * const customHex = CustomGrid.Hex()\n     * hex.size     // 10\n     * hex.custom   // 🤓\n     */\n    return function defineGrid(Hex = extendHex()) {\n        // static properties\n        Object.assign(GridFactory, {\n            /**\n             * The {@link Hex} factory the Grid factory was created with.\n             * @memberof Grid\n             * @static\n             * @function\n             */\n            // don't manually bind `this` to Hex (i.e. `Hex.call`/`Hex.apply`) anywhere in the source\n            // it could cause this:\n            // function methodThatBindsThis() {\n            //     return Hex.call(this, ...) <- `this` refers to `GridFactory`\n            // }\n            // which is caused by the following line:\n            Hex,\n\n            // methods\n            /**\n             * @memberof Grid\n             * @static\n             * @method\n             *\n             * @param {*} value     Any value.\n             * @returns {boolean}   Whether the passed value is a valid hex.\n             */\n            isValidHex,\n            pointToHex: statics.pointToHexFactory({ Point, Hex }),\n            parallelogram: statics.parallelogramFactory({ Grid, Hex }),\n            triangle: statics.triangleFactory({ Grid, Hex }),\n            hexagon: statics.hexagonFactory({ Grid, Hex }),\n            rectangle: statics.rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo })\n        })\n\n        // prototype properties\n        Object.assign(\n            Grid.prototype,\n            {\n                // methods\n                get: methods.get,\n                hexesBetween: methods.hexesBetween,\n                hexesInRange: methods.hexesInRangeFactory({ isValidHex }),\n                neighborsOf: methods.neighborsOfFactory({\n                    isValidHex,\n                    signedModulo,\n                    compassToNumberDirection\n                }),\n                set: methods.setFactory({ isValidHex })\n            }\n        )\n\n        /**\n         * @function Grid\n         *\n         * @description\n         * A function to create hex {@link grid}s and perform various operations on them.\n         *\n         * A Grid factory has several static methods that return {@link grid}s of hexes in a certain shape.\n         * It can also be called with 1 or more hexes or an array of hexes to construct/clone a {@link grid} containing those hexes.\n         *\n         * A {@link grid} extends `Array.prototype`, with some methods overwritten and some new methods added.\n         *\n         * @param {(hex[]|hex)} [arrayOrHex]    An array or a hex. Any invalid hexes are filtered out.\n         * @param {...hex} [hexes]              More hexes. Any invalid hexes are filtered out.\n         *\n         * @returns {grid}                      A grid instance containing only valid hexes.\n         *\n         * @example\n         * const Grid = Honeycomb.defineGrid()\n         * // the Hex factory used by the Grid to produce hexes is available as a property\n         * const Hex = Grid.Hex\n         *\n         * Grid(Hex(3, -1), Hex(2, 0))      // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         * Grid([Hex(3, -1), Hex(2, 0)])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         *\n         * // invalid hexes are filtered out:\n         * Grid('no hex', { x: 3, y: -1 })  // []\n         * Grid(['no hex', Hex(1, -1)])     // [{ x: 1, y: -1 }]\n         *\n         * // clone a grid:\n         * const grid = Grid(Hex(), Hex(1), Hex(2))\n         * const clonedGrid = Grid(grid)    // [{ x: 0, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 2 }]\n         * grid === clonedGrid              // false\n         */\n        function GridFactory(arrayOrHex, ...hexes) {\n            if (isArray(arrayOrHex)) {\n                hexes = arrayOrHex\n            } else {\n                hexes.unshift(arrayOrHex)\n            }\n\n            /**\n             * @typedef {Object} grid\n             * @extends Array\n             *\n             * @property {number} length    Amount of hexes in the grid.\n             */\n            return new Grid(...hexes.filter(isValidHex))\n        }\n\n        return GridFactory\n    }\n}\n","import { isString } from 'axis.js'\nimport { offsetFromZero } from '../utils'\n\nexport function pointToHexFactory({ Hex }) {\n    /**\n     * Converts the passed {@link point} to a hex. Internally calls {@link Hex#fromPoint}.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link Hex#fromPoint}\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 50 })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * const Point = Honeycomb.Point\n     *\n     * Grid.pointToHex(Point(120, 280))     // { x: 0, y: 3 }\n     * Grid.pointToHex(120, 280)            // { x: 0, y: 3 }\n     * Grid.pointToHex({ x: 120, y: 280 })  // { x: 0, y: 3 }\n     * Grid.pointToHex([ 120, 280 ])        // { x: 0, y: 3 }\n     */\n    return function pointToHex(pointOrX, y) {\n        return Hex().fromPoint(pointOrX, y)\n    }\n}\n\nexport function parallelogramFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [parallelogram](https://en.wikipedia.org/wiki/Parallelogram) ▱.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(1|3|5)} [options.direction=1]       The direction (from the start hex) in which to create the shape.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a parallelogram arrangement.\n     */\n    return function parallelogram({\n        width,\n        height,\n        start,\n        direction = 1,\n        /**\n         * Callback of a {@link Grid} shape method.\n         * Gets called for each hex that's about to be added to the grid.\n         *\n         * @callback onCreate\n         * @param {hex} hex     The freshly created hex, just before it's added to the grid.\n         * @param {grid} grid   The grid (for as far as it's created).\n         * @returns {void}      Nothing.\n         */\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: ['q', 'r', 's'],\n            3: ['r', 's', 'q'],\n            5: ['s', 'q', 'r']\n        }\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let first = 0; first < width; first++) {\n            for (let second = 0; second < height; second++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function triangleFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [(equilateral) triangle](https://en.wikipedia.org/wiki/Equilateral_triangle) △.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.size                 The side length (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex. **Note**: it's not the first hex, but rather a hex relative to the triangle.\n     * @param {(1|5)} [options.direction=1]         The direction in which to create the shape. Each direction corresponds to a different arrangement of hexes. In this case a triangle pointing up (`direction: 1`) or down (`direction: 5`) (with pointy hexes) or right (`direction: 1`) or left (`direction: 5`) (with flat hexes).\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a triangle arrangement.\n     */\n    return function triangle({\n        size,\n        start,\n        direction = 1,\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: {\n                rStart: () => 0,\n                rEnd: q => size - q\n            },\n            5: {\n                rStart: q => size - q,\n                rEnd: () => size + 1\n            }\n        }\n        const { rStart, rEnd } = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let q = 0; q < size; q++) {\n            for (let r = rStart(q); r < rEnd(q); r++) {\n                const hex = Hex(start.cubeToCartesian({\n                    q: q + start.q,\n                    r: r + start.r,\n                    s: -q - r + start.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function hexagonFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [hexagon](https://en.wikipedia.org/wiki/Hexagon) ⬡.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n     * @param {hex} [options.center=Hex(0)]         The center hex.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a hexagon arrangement.\n     */\n    return function hexagon({\n        radius,\n        center,\n        onCreate = () => { }\n    }) {\n        center = Hex(center)\n\n        const grid = new Grid()\n\n        for (let q = -radius; q <= radius; q++) {\n            const startR = Math.max(-radius, -q - radius)\n            const endR = Math.min(radius, -q + radius)\n\n            for (let r = startR; r <= endR; r++) {\n                const hex = Hex(center.cubeToCartesian({\n                    q: q + center.q,\n                    r: r + center.r,\n                    s: -q - r + center.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }) {\n    /**\n     * Creates a grid in the shape of a [rectangle](https://en.wikipedia.org/wiki/Rectangle) ▭.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(COMPASS_DIRECTION|number)} [options.direction=E|S]\n     * The direction (from the start hex) in which to create the shape.\n     * Defaults to `0` (`E`) for pointy hexes and `1` (`S`) for flat hexes.\n     * Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a rectangular arrangement.\n     */\n    return function rectangle({\n        width,\n        height,\n        start,\n        direction = Hex().isPointy() ? 0 : 1, // E or S\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n\n        if (isString(direction)) {\n            direction = compassToNumberDirection(direction, start.orientation)\n        }\n\n        if (direction < 0 || direction > 5) {\n            direction = signedModulo(direction, 6)\n        }\n\n        const DIRECTIONS = [\n            ['q', 'r', 's'],\n            ['r', 'q', 's'],\n            ['r', 's', 'q'],\n            ['s', 'r', 'q'],\n            ['s', 'q', 'r'],\n            ['q', 's', 'r']\n        ]\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const [firstStop, secondStop] = start.isPointy() ? [width, height] : [height, width]\n        const grid = new Grid()\n\n        for (let second = 0; second < secondStop; second++) {\n            const secondOffset = offsetFromZero(start.offset, second)\n\n            for (let first = -secondOffset; first < firstStop - secondOffset; first++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n"],"names":["module","axis","types","split","type","Object","prototype","toString","call","this","slice","i","length","self","elem","factory","offsetFromZero","offset","distance","signedModulo","dividend","divisor","compassToNumberDirection","value","orientation","test","Error","toLowerCase","toUpperCase","includes","pointy","E","SE","SW","W","NW","NE","flat","S","N","ensureXY","x","y","isNumber","DIRECTION_COORDINATES","q","r","DIAGONAL_DIRECTION_COORDINATES","EPSILON","sqrt3","Math","sqrt","coordinates","cube","s","cubeToCartesian","isPointy","isFlat","oppositeCornerDistance","size","oppositeSideDistance","width","height","hex","max","abs","nudge","add","staticMethods","thirdCoordinate","firstCoordinate","secondCoordinate","get","keyOrPoint","indexOf","hexesBetween","firstHex","lastHex","step","hexes","lerp","round","push","PointFactory","Point","pointOrX","methods","subtract","multiply","divide","isArray","isObject","assign","create","Grid","Array","__isHoneycombHex","fill","TypeError","point","fromIndex","Number","equals","lastIndexOf","min","super","filter","isValidHex","splice","start","deleteCount","unshift","extendHex","cartesianToCube","defaultPrototype","origin","Hex","cartesian","center","corners","fromPoint","t","roundedQ","roundedR","roundedS","diffQ","diffR","diffS","set","args","toCartesian","toCube","toPoint","finalPrototype","xOrProps","customProps","rest","extendHexFactory","defineGrid","GridFactory","arrayOrHex","pointToHex","statics","parallelogram","direction","onCreate","grid","first","second","triangle","rStart","rEnd","hexagon","radius","startR","endR","rectangle","isString","firstStop","secondStop","secondOffset","hexesInRange","centerHex","range","includeCenterHex","Boolean","neighborsOf","directions","diagonal","concat","map","newHex","index","defineGridFactory"],"mappings":"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"}